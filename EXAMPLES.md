# Example: Generated Test Files

This document shows examples of the Jest unit tests generated by the Angular Unit Tests CLI.

## Component Test Example

**Source File**: `app.component.ts`

```typescript
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  title = 'test-angular-app';

  ngOnInit(): void {
    console.log('App component initialized');
  }
}
```

**Generated Test File**: `app.component.spec.ts`

```typescript
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  let component: AppComponent;
  let fixture: ComponentFixture<AppComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [AppComponent]
    }).compileComponents();

    fixture = TestBed.createComponent(AppComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it('should render component', () => {
    expect(fixture.nativeElement).toBeTruthy();
  });

  it('should have correct initial state', () => {
    expect(component).toMatchSnapshot();
  });

  it('should handle lifecycle hooks', () => {
    const ngOnInitSpy = jest.spyOn(component, 'ngOnInit');
    component.ngOnInit();
    expect(ngOnInitSpy).toHaveBeenCalled();
  });

  it('should handle change detection', () => {
    fixture.detectChanges();
    expect(fixture.nativeElement).toMatchSnapshot();
  });
});
```

## Service Test Example

**Source File**: `user.service.ts`

```typescript
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class UserService {
  private apiUrl = '/api/users';

  constructor(private http: HttpClient) { }

  getUsers(): Observable<any> {
    return this.http.get(this.apiUrl);
  }

  getUserById(id: number): Observable<any> {
    return this.http.get(`${this.apiUrl}/${id}`);
  }
}
```

**Generated Test File**: `user.service.spec.ts`

```typescript
import { TestBed } from '@angular/core/testing';
import { UserService } from './user.service';

describe('UserService', () => {
  let service: UserService;

  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [UserService]
    });
    service = TestBed.inject(UserService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  it('should have correct initial state', () => {
    expect(service).toBeDefined();
  });

  it('should handle method calls', () => {
    // Test service methods here
    expect(service).toMatchSnapshot();
  });

  it('should handle errors gracefully', () => {
    // Test error handling
    expect(service).toBeTruthy();
  });

  it('should maintain state correctly', () => {
    // Test state management
    expect(service).toBeTruthy();
  });
});
```

## Pipe Test Example

**Source File**: `date-format.pipe.ts`

```typescript
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'dateFormat'
})
export class DateFormatPipe implements PipeTransform {
  transform(value: Date | string, format: string = 'short'): string {
    if (!value) return '';
    
    const date = typeof value === 'string' ? new Date(value) : value;
    return date.toLocaleDateString();
  }
}
```

**Generated Test File**: `date-format.pipe.spec.ts`

```typescript
import { DateFormatPipe } from './date-format.pipe';

describe('DateFormatPipe', () => {
  let pipe: DateFormatPipe;

  beforeEach(() => {
    pipe = new DateFormatPipe();
  });

  it('should create pipe', () => {
    expect(pipe).toBeTruthy();
  });

  it('should transform value', () => {
    const result = pipe.transform('test');
    expect(result).toBeDefined();
  });

  it('should handle null values', () => {
    const result = pipe.transform(null);
    expect(result).toBeDefined();
  });

  it('should handle undefined values', () => {
    const result = pipe.transform(undefined);
    expect(result).toBeDefined();
  });

  it('should handle edge cases', () => {
    const result = pipe.transform('');
    expect(result).toBeDefined();
  });
});
```

## Test Coverage Features

Each generated test includes patterns to achieve 80% test coverage:

1. **Creation Tests**: Verify the object can be instantiated
2. **Initial State Tests**: Check the object's initial state
3. **Method Tests**: Test primary methods and behaviors
4. **Edge Case Tests**: Handle null, undefined, and boundary conditions
5. **Error Handling Tests**: Verify proper error handling
6. **Lifecycle Tests** (for components): Test Angular lifecycle hooks

## Discriminating Values

If a test file already exists, the CLI automatically adds a discriminating number:

- First generation: `app.component.spec.ts`
- Second generation: `app.component.spec.2.ts`
- Third generation: `app.component.spec.3.ts`

This ensures existing tests are never overwritten.
